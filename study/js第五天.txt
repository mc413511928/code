JS函数
	1实参是一个数组，形参接受的也是一个数组，
	2在我们实际开发中我们经常用一个变量来接受函数的返回值，使用更简单
return
	1return终止函数，后面的 代码不会被执行。
	2return只能返回一个值，返回的结果是最后一个值。
	3想要多个值我们用数组或者对象来实现，
	4我们的函数如果有return则返回的是return后面的值，如果没有返回的是undefind;
	5不仅退出循环还能退出return语句中的值，同时还结束当前函数体内的代码，
argunments
	1里面储存了所有传递过来的的实参
	2传递过来的是伪数组
		1伪数组具有数组的length属性
		2按照索引的方式进行储存的
		3他没有真正数组的一些方法；比如pop();push();
		4我们可以按照数组的方式遍历arguments
		5有了arguments我们就可以不用写形参了 ，
	3只有函数才有arguments对象，畏怯每个函数都内置好了这个arguments,
函数封装
	1sort排序的意思
	2函数是可以相互调用的， 
函数的命名
	函数表达式var fun=function(){}
			fun();
	1函数表达式（匿名函数）
	2是没有名字fun是变量名不是函数名	
	3函数表达式和声明变量差不多，只不过是变量存的是值，函数表达式存的是函数，
	4函数表达式也可以传递参数的，
作用域
	
	1javascript作用域：目的提高程序更改的可靠性更重要的是减少命名冲突，
	2JS作用域
		1全局作用域  局部作用域
		1全局作用域：整个script标签，或者是单独的js文件，
		2局部作用：在函数内部就是局部作用域，这个代码的名字只在函数内部起效果和作用；又叫做函数作用域，
变量的作用域：根据作用域不同我们变量也分为全局变量和局部变量
	1全局变量：在全局下都可以使用；注意如果在函数内部没有申明直接赋值的变量也属于全局变量，任何一个地方都可以用，
	2局部变量：祝能在函数内部使用：函数的形参也可以看做是局部变量。
	3从执行效率来看全局变量和局部变量
		1全局变量只有浏览器关闭的时候才会销毁，比较占资源
		2局部变量函数执行完毕就销毁，更节省资源，
块级作用域
	1{}抱起来的就是块级作用域，
作用域链：内部函数访问外部函数的变量采用链式查找； 采用就近原则。

	1内部函数可以访问外部函数的，
	
预解析
	1我们js引擎运行jS分两步，
		1预解析js引擎会把js中所有的var function提到当前作用域最前面，
	2函数表达式，必须把调用函数放在函数后面才能执行，
预解析分为：变量预解析，函数预解析，
	1变量提升 就是把所有变量的申明提到道歉作用域的最前面，不提升 赋值操作；
	2函数提升就是把所有函数申明提升到当前作用域的最前面，不调用函数，
	  // function f1() {
        //     var a = b = c = 9;这里的bc是全局变量任何地方都可以用
        //     console.log(a);
        //     console.log(b);
        //     console.log(c);

        // }

对象：一组无序的属性和方法的集合，
	1对象是有2个部分组成方法和属性；
	2好处：表 达结构更加清晰明确，更加强大，	
对象的创建
	1利用字面量创建{}
		1里面的 属性或者方法是采用键  属性：值
		2多个属性护着方法中间是逗号隔开的，
		3方法冒号后面跟的是匿名函数

	2使用对象
		1调用对象的属性我们采取 对象名.属性名这个.我们理解为的；
		2调用属性还有一种方法，对象名['属性名']；
		3调用对象的方法 对象名.方法名，obj.sayHi();千万别忘记加小括号，
